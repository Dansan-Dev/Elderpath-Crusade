
buildscript {
  repositories {
    gradlePluginPortal()
  }
  dependencies {
    classpath "io.github.fourlastor:construo:1.7.1"
    if(enableGraalNative == 'true') {
      classpath "org.graalvm.buildtools.native:org.graalvm.buildtools.native.gradle.plugin:0.9.28"
    }
  }
}
plugins {
  id "application"
}
apply plugin: 'io.github.fourlastor.construo'


import io.github.fourlastor.construo.Target

sourceSets.main.resources.srcDirs += [ rootProject.file('assets').path ]
mainClassName = 'io.github.forest_of_dreams.lwjgl3.Lwjgl3Launcher'
application.setMainClass(mainClassName)
eclipse.project.name = appName + '-lwjgl3'
java.sourceCompatibility = 17
java.targetCompatibility = 17
if (JavaVersion.current().isJava9Compatible()) {
  compileJava.options.release.set(17)
}

dependencies {
  implementation "com.badlogicgames.gdx:gdx-backend-lwjgl3:$gdxVersion"
  implementation "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-desktop"
  implementation "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-desktop"
  implementation "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
  implementation project(':core')

  if(enableGraalNative == 'true') {
    implementation "io.github.berstanio:gdx-svmhelper-backend-lwjgl3:$graalHelperVersion"
    implementation "io.github.berstanio:gdx-svmhelper-extension-freetype:$graalHelperVersion"

  }
}


def os = System.properties['os.name'].toLowerCase()

run {
  workingDir = rootProject.file('assets').path
// You can uncomment the next line if your IDE claims a build failure even when the app closed properly.
  //setIgnoreExitValue(true)

  if (os.contains('mac')) jvmArgs += "-XstartOnFirstThread"
}

jar {
// sets the name of the .jar file this produces to the name of the game or app, with the version after.
  archiveFileName.set("${appName}-${projectVersion}.jar")
// the duplicatesStrategy matters starting in Gradle 7.0; this setting works.
  duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
  dependsOn configurations.runtimeClasspath
  from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
// these "exclude" lines remove some unnecessary duplicate files in the output JAR.
  exclude('META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    exclude('META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
// setting the manifest makes the JAR runnable.
  manifest {
    attributes 'Main-Class': project.mainClassName
  }
// this last step may help on some OSes that need extra instruction to make runnable JARs.
  doLast {
    file(archiveFile).setExecutable(true, false)
  }
}


construo {
  // name of the executable
  name.set(appName)
  // human-readable name, used for example in the `.app` name for macOS
  humanName.set(appName)
  // Optional, defaults to project version property
  version.set("$projectVersion")

  jlink {
    // avoid parsing jdeps output (we'll provide the modules explicitly)
    guessModulesFromJar.set(false)

    // LWJGL requires sun.misc.Unsafe which lives in jdk.unsupported on Java 9+.
    // Include java.desktop for AWT-dependent features used by libGDX/LWJGL.
    modules.add("java.base")
    modules.add("java.desktop")
    modules.add("java.net.http")
    modules.add("jdk.unsupported")
  }

  targets.configure {
    register("linuxX64", Target.Linux) {
      architecture.set(Target.Architecture.X86_64)
      jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_linux_hotspot_17.0.15_6.tar.gz")
      // Linux does not currently have a way to set the icon on the executable
    }
    register("macM1", Target.MacOs) {
      architecture.set(Target.Architecture.AARCH64)
      jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_aarch64_mac_hotspot_17.0.15_6.tar.gz")
      // macOS needs an identifier
      identifier.set("io.github.forest_of_dreams." + appName)
      // Optional: icon for macOS, as an ICNS file
      macIcon.set(project.file("icons/icon-64.png"))
    }
    register("macX64", Target.MacOs) {
      architecture.set(Target.Architecture.X86_64)
      jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_mac_hotspot_17.0.15_6.tar.gz")
      // macOS needs an identifier
      identifier.set("io.github.forest_of_dreams." + appName)
      // Optional: icon for macOS, as an ICNS file
      macIcon.set(project.file("icons/icon-64.png"))
    }
    register("winX64", Target.Windows) {
      architecture.set(Target.Architecture.X86_64)
      // Optional: icon for Windows, as a PNG (use 256px for better taskbar fidelity)
      icon.set(project.file("icons/icon-256.png"))
      jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_windows_hotspot_17.0.15_6.zip")
      // Uncomment the next line to show a console when the game runs, to print messages.
      //useConsole.set(true)
    }
  }
}

// Equivalent to the jar task; here for compatibility with gdx-setup.
tasks.register('dist') {
  dependsOn 'jar'
}

distributions {
  main {
    contents {
      into('libs') {
        project.configurations.runtimeClasspath.files.findAll { file ->
          file.getName() != project.tasks.jar.outputs.files.singleFile.name
        }.each { file ->
          exclude file.name
        }
      }
    }
  }
}

startScripts.dependsOn(':lwjgl3:jar')
startScripts.classpath = project.tasks.jar.outputs.files

if(enableGraalNative == 'true') {
  apply from: file("nativeimage.gradle")
}


// Include README.md at the root of the application distribution so Construo packages it too
// This avoids touching Construo's internal PackageTask API and works across all targets.
distributions {
  main {
    contents {
      from(rootProject.file('README.md'))
    }
  }
}


// As Construo zips the staged content under build/construo/<target>/roast, inject README.md there right before packaging.
[
  [name: 'LinuxX64', folder: 'linuxX64'],
  [name: 'MacM1',    folder: 'macM1'],
  [name: 'MacX64',   folder: 'macX64'],
  [name: 'WinX64',   folder: 'winX64']
].each { cfg ->
  def injectTask = tasks.register("injectReadme${cfg.name}") {
    dependsOn tasks.matching { it.name == "roast${cfg.name}" }
    doLast {
      def roastDir = file("${buildDir}/construo/${cfg.folder}/roast")
      if (!roastDir.exists()) {
        roastDir.mkdirs()
      }
      copy {
        from rootProject.file('README.md')
        into roastDir
      }
    }
  }
  tasks.matching { it.name == "package${cfg.name}" }.configureEach {
    dependsOn injectTask
  }
}

// Inject Linux desktop entry and icon into the staged directory before zipping so they appear in the package
// This uses existing icon from src/main/resources and generates the .desktop if not present under root packaging

def injectLinuxDesktop = tasks.register("injectLinuxDesktop") {
  dependsOn tasks.matching { it.name == "roastLinuxX64" }
  doLast {
    def roastDir = file("${buildDir}/construo/linuxX64/roast")
    if (!roastDir.exists()) roastDir.mkdirs()

    // Ensure icons directory exists
    def iconsDir = new File(roastDir, "icons")
    if (!iconsDir.exists()) iconsDir.mkdirs()

    // Copy icon (prefer 256)
    def iconSrc = project.file("src/main/resources/icon-256.png")
    if (iconSrc.exists()) {
      copy {
        from iconSrc
        into iconsDir
      }
    }

    // Ensure install.sh is present in the package root and executable
    def sourceInstaller = project.file("packaging/linux/resources/install.sh")
    def stagedInstaller = new File(roastDir, "install.sh")
    if (sourceInstaller.exists()) {
      copy {
        from sourceInstaller
        into roastDir
      }
    }
    stagedInstaller.setExecutable(true, false)

    // Ensure uninstall.sh is present in the package root and executable
    def sourceUninstaller = project.file("packaging/linux/resources/uninstall.sh")
    def stagedUninstaller = new File(roastDir, "uninstall.sh")
    if (sourceUninstaller.exists()) {
      copy {
        from sourceUninstaller
        into roastDir
      }
    }
    stagedUninstaller.setExecutable(true, false)

    // Do NOT include .desktop in the ZIP anymore; the installer will generate it in the user's system
  }
}

tasks.matching { it.name == "packageLinuxX64" }.configureEach {
  dependsOn injectLinuxDesktop
}
